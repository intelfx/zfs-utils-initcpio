#!/usr/bin/busybox sh
# shellcheck shell=busybox disable=SC3001,SC3003

# cmdline format:
#
# use a particular dataset:
#    root=zfs:pool/dataset
# use the bootfs property of a pool:
#    root=zfs:pool
# import all pools and use the first one with a bootfs property:
#    root=zfs

set -eo pipefail

SCRIPT_NAME="zfs-root-generator"
LIB_DIR="/usr/lib/zfs/initcpio"
# shellcheck source=zfs-functions
. "$LIB_DIR/zfs-functions"


#
# functions
#

enable_unit() {
	local unit="$1" target="$2"
	log "adding $unit to $target"
	install -dm755 "$GENERATOR_DIR/$target.wants"
	ln -rsf "$GENERATOR_DIR/$unit" -t "$GENERATOR_DIR/$target.wants"
}

write_unit() {
	local unit="$1"
	log "writing $unit"
	{
		cat <<-"EOF"
		# Automatically generated by zfs-root-generator

		EOF
		cat
	} | install -Dm644 /dev/stdin "$GENERATOR_DIR/$unit"
}

write_common_units() {
	write_unit zfs-initrd-prepare.service <<-EOF
	[Unit]
	Description=Prepare to mount ZFS rootfs
	DefaultDependencies=no
	Wants=zfs-initrd-import.target
	After=zfs-initrd-import.target
	Before=initrd-root-device.target

	[Service]
	Type=oneshot
	RemainAfterExit=yes
	EnvironmentFile=-/etc/default/zfs
	EnvironmentFile=-${STATE_FILE}
	ExecStart=${LIB_DIR}/zfs-prepare-rootfs
	EOF

	enable_unit zfs-initrd-prepare.service initrd-root-device.target
}

write_import_unit() {
	local import_cmds

	case "${ZFS_ROOT_MODE?}" in
		all) import_cmds="\
ExecStart=/usr/bin/zpool import -N -o cachefile=none -a
" ;;

		pool|dataset) import_cmds="\
ExecStart=/usr/bin/zpool import -N -o cachefile=none \${ZFS_ROOT_POOL}
" ;;

		*) die "invalid \$ZFS_ROOT_MODE=\"$ZFS_ROOT_MODE\"" ;;
	esac

	write_unit zfs-initrd-import-scan.service <<-EOF
	[Unit]
	Description=Import ZFS rootfs pool(s) by device scanning
	Documentation=man:zpool(8)
	DefaultDependencies=no
	Requires=systemd-udev-settle.service
	After=systemd-udev-settle.service
	After=cryptsetup.target
	After=multipathd.service
	Before=zfs-initrd-import.target
	ConditionPathIsDirectory=/sys/module/zfs

	[Service]
	Type=oneshot
	RemainAfterExit=yes
	EnvironmentFile=-/etc/default/zfs
	EnvironmentFile=-${STATE_FILE}
	${import_cmds}
	EOF

	write_unit zfs-initrd-import.target <<-EOF
	[Unit]
	Description=ZFS rootfs pool import target
	Before=initrd-root-device.target
	EOF

	enable_unit zfs-initrd-import-scan.service zfs-initrd-import.target
	enable_unit zfs-initrd-import.target initrd-root-device.target
}

write_mount_unit() {
	local what="$1" where="$2" unit

	unit="$(systemd-escape --path --suffix=mount "$where")"
	write_unit "$unit" <<-EOF
	[Mount]
	Type=zfs
	What=${what}
	Where=${where}
	Options=zfsutil
	EnvironmentFile=${STATE_FILE}
	EOF
}

write_sysroot_unit() {
	# install -Dm644 /dev/stdin "$GENERATOR_DIR/sysroot.mount.d/zfs-override.conf"
	write_mount_unit "\${ZFS_ROOT_DATASET}" "/sysroot"
}

write_sysroot_recursive() {
	local name canmount mountpoint
	# mountpoint of the designated root dataset
	# (this is supposed to be /, but might not be; compensate for it)
	# TODO: once openzfs/zfs#4553 and openzfs/zfs#985 are fully resolved,
	#       use temporary mountpoints here
	local mountbase
	# mountpoint relative to mountbase, normalized (see below)
	local relpoint
	# temporary mountpoint under /sysroot
	local sysrootpoint

	# Woo, another normalization dance...
	#
	# mountpoint=/            mountbase=/        relpoint=      sysrootpoint=/sysroot
	# mountpoint=/usr         mountbase=/        relpoint=/usr  sysrootpoint=/sysroot/usr
	# mountpoint=/target      mountbase=/target  relpoint=      sysrootpoint=/sysroot
	# mountpoint=/target/usr  mountbase=/target  relpoint=/usr  sysrootpoint=/sysroot/usr
	#
	while IFS=$'\t' read -r name canmount mountpoint; do
		if [[ "$name" == "$ZFS_ROOT_DATASET" ]]; then
			if [[ "$mountpoint" != "/" ]]; then
				log "warning: root dataset \"$ZFS_ROOT_DATASET\" has mountpoint=\"$mountpoint\"" 4
				log "note: root dataset should have mountpoint=\"/\"" 5
				log "note: this will be compensated for, but newly created descendant datasets will not be mounted properly until reboot" 5
			fi
			mountbase="$mountpoint"

			if [[ "$canmount" == "off" ]]; then
				log "error: root dataset \"$ZFS_ROOT_DATASET\" has canmount=\"$canmount\"" 3
				log "note: root dataset should have canmount=(noauto|on)" 5
				log "note: this will be compensated for, but things may break" 5
			fi
			canmount="(override)"
		fi

		if [[ "$canmount" == off ]]; then
			log "debug: nested dataset \"$name\" has canmount=\"$canmount\"" 7
			log "debug: this dataset will be ignored" 7
			continue
		fi

		# unfortunately, busybox ash [[ expansion rules are braindead
		# and it cannot be used for anything where rhs consists of a
		# literal part and a pattern part, e.g.:
		#   if ! [[ "$mountpoint" == "$mountbase" || "$mountpoint" == "${mountbase%/}"/* ]]; then
		# anyway, normalization dance
		case "$mountpoint" in
		"$mountbase")
			relpoint='' ;;
		"${mountbase%/}"/*)
			relpoint="${mountpoint#"${mountbase%/}"}" ;;
		*)
			log "debug: nested dataset \"$name\" has mountpoint=\"$mountpoint\" not under \"$mountbase\"" 7
			log "debug: this dataset will be ignored" 7
			continue
			;;
		esac

		sysrootpoint="/sysroot$relpoint"

		log "debug: dataset=\"$name\" canmount=\"$canmount\" mountpoint=\"$mountpoint\" (mountbase=\"$mountbase\") target=\"$sysrootpoint\"" 7
		write_mount_unit "$name" "$sysrootpoint"

	done < <(zfs list -Ho name,canmount,mountpoint -r "${ZFS_ROOT_DATASET:?}")
}


#
# main
#

setup_debug

GENERATOR_DIR="$1"
if ! [[ "$GENERATOR_DIR" && -d "$GENERATOR_DIR" ]]; then
	die "invalid generator directory \"$GENERATOR_DIR\""
fi

if vars_present; then
	load_vars
else
	parse_cmdline
fi

case "${ZFS_ROOT_MODE?}" in
all|pool|dataset) ;;
none) log "nothing to do"; exit 0 ;;
*) die "invalid \$ZFS_ROOT_MODE=\"$ZFS_ROOT_MODE\"" ;;
esac

write_common_units
write_import_unit

# if the designated root dataset exists
if [[ $ZFS_ROOT_POOL && $ZFS_ROOT_DATASET ]] \
&& zfs list -Ho name "$ZFS_ROOT_DATASET" &>/dev/null; then
	log "pool opened and dataset exists, writing nested mount units"
	write_sysroot_recursive
else
	log "pool not opened or dataset does not exist, writing sysroot.mount only"
	write_sysroot_unit
fi

dump_vars

log "done"
exit 0

# vim: ft=sh ts=8 noet:
